# build.py
"""
build.py - simple build helper for PDF Toolkit

Usage:
  python build.py                      # increment build number, generate versionfile, run pyinstaller on spec
  python build.py --no-increment       # don't bump the build counter
  python build.py --generate-only      # only generate build/versionfile.txt (useful for testing)
  python build.py --spec PDF-Toolkit-GUI.spec  # specify spec file to build
  python build.py --bump-patch         # bump patch, reset build to 0
  python build.py --bump-minor         # bump minor, reset patch/build to 0
  python build.py --bump-major         # bump major, reset minor/patch/build to 0
"""
import sys
import subprocess
from pathlib import Path
from datetime import datetime
import argparse
import shutil

ROOT = Path(__file__).resolve().parent
BUILD_DIR = ROOT / 'build'
VERSION_FILE = BUILD_DIR / 'VERSION'
VERSIONFILE_TXT = BUILD_DIR / 'versionfile.txt'
DEFAULT_SPEC = 'PDF-Toolkit-GUI.spec'
# Default Windows-specific output locations (does not affect spec if user overrides)
DIST_DIR = ROOT / 'dist' / 'windows'
WORK_DIR = ROOT / 'build' / 'pyi-windows'

# Must be a single VSVersionInfo(...) expression; no imports or other statements.
TEMPLATE = r"""# UTF-8
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=({MAJOR}, {MINOR},0,0),
    prodvers=({MAJOR}, {MINOR},0,0),
    mask=0x3f,
    flags=0x0,
    OS=0x4,
    fileType=0x1,
    subtype=0x0,
  ),
  kids=[
    StringFileInfo([
      StringTable(
        u'040904B0',
        [
          StringStruct(u'CompanyName', u'{COMPANY}'),
          StringStruct(u'FileDescription', u'{DESCRIPTION}'),
          StringStruct(u'FileVersion', u'{VER_STR}'),
          StringStruct(u'InternalName', u'{NAME}'),
          StringStruct(u'LegalCopyright', u'{COPY}'),
          StringStruct(u'OriginalFilename', u'{NAME}.exe'),
          StringStruct(u'ProductName', u'{PRODUCT}'),
          StringStruct(u'ProductVersion', u'{VER_STR}'),
        ]
      )
    ]),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
"""

def read_version():
    if not VERSION_FILE.exists():
        return [1, 0]
    txt = VERSION_FILE.read_text(encoding='utf-8').strip()
    parts = txt.split('.')
    try:
        nums = [int(p) for p in parts]
    except Exception:
        print('Invalid version in', VERSION_FILE, ' - resetting to 1.0')
        nums = [1, 0]
    while len(nums) < 2:
        nums.append(0)
    return nums[:2]

def write_version(nums):
    BUILD_DIR.mkdir(exist_ok=True)
    VERSION_FILE.write_text('.'.join(str(n) for n in nums), encoding='utf-8')

def generate_versionfile(nums, meta=None):
    meta = meta or {}
    ver_str = '.'.join(str(n) for n in nums)
    data = TEMPLATE.format(
        MAJOR=nums[0], MINOR=nums[1],
        COMPANY=meta.get('company', 'Your Company'),
        DESCRIPTION=meta.get('description', 'PDF Toolkit GUI'),
        NAME=meta.get('name', 'PDF-Toolkit-GUI'),
        COPY=meta.get('copyright', f'Copyright (c) {datetime.now().year} Konstantinos Tsouvalis'),
        PRODUCT=meta.get('product', 'PDF Toolkit GUI'),
        VER_STR=ver_str,
    )
    BUILD_DIR.mkdir(exist_ok=True)
    VERSIONFILE_TXT.write_text(data, encoding='utf-8')

    # Also generate a small `version.py` module at project root so the application can import it.
    version_py = ROOT / 'version.py'
    version_py.write_text(
        "# Auto-generated by build.py\n__version__ = '{ver}'\n".format(ver=ver_str),
        encoding='utf-8'
    )
    print('Wrote', VERSIONFILE_TXT, 'and', version_py)
    return VERSIONFILE_TXT

def run_pyinstaller(spec_path, dist_dir=None, work_dir=None):
    # Use current interpreter to ensure correct environment
    cmd = [sys.executable, '-m', 'PyInstaller']
    if dist_dir:
        cmd += ['--distpath', str(dist_dir)]
    if work_dir:
        cmd += ['--workpath', str(work_dir)]
    cmd.append(spec_path)
    print('Running:', ' '.join(cmd))
    subprocess.check_call(cmd, cwd=str(ROOT))

def main(argv):
    p = argparse.ArgumentParser()
    p.add_argument('--no-increment', action='store_true', help='Do not increment build number')
    p.add_argument('--generate-only', action='store_true', help='Only generate versionfile.txt and exit')
    p.add_argument('--bump-minor', action='store_true', help='Increment the minor version (resets patch/build to 0)')
    p.add_argument('--bump-major', action='store_true', help='Increment the major version (resets minor/patch/build to 0)')
    p.add_argument('--spec', default=DEFAULT_SPEC, help='Spec file to build')
    p.add_argument('--clean-dist', action='store_true', help='Remove the dist directory before building to avoid leftover artifacts')
    p.add_argument('--distpath', default=str(DIST_DIR), help='Override dist output path (default: dist/windows)')
    p.add_argument('--workpath', default=str(WORK_DIR), help='Override work path (default: build/pyi-windows)')
    args = p.parse_args(argv)

    if args.no_increment and (args.bump_minor or args.bump_major):
        print('ERROR: --no-increment cannot be combined with --bump-minor, or --bump-major')
        return 2

    nums = read_version()
    if args.bump_major:
        nums[0] += 1
        nums[1] = 0
        write_version(nums)
        print('Bumped MAJOR version to', '.'.join(map(str, nums)))
    elif args.bump_minor:
        nums[1] += 1
        write_version(nums)
        print('Bumped MINOR version to', '.'.join(map(str, nums)))
    elif not args.no_increment:
        nums[-1] += 1
        write_version(nums)
        print('Bumped BUILD version to', '.'.join(map(str, nums)))
    else:
        print('Using existing version', '.'.join(map(str, nums)))

    vf = generate_versionfile(nums)
    print('Wrote version file to', vf)

    if args.generate_only:
        print('generate-only: exiting before building')
        return 0

    dist_override = Path(args.distpath)
    work_override = Path(args.workpath)

    if args.clean_dist and dist_override.exists():
        try:
            shutil.rmtree(dist_override)
            print('Removed', dist_override)
        except (OSError, shutil.Error) as e:
            print('Warning: failed to remove', dist_override, '-', e)

    try:
        run_pyinstaller(args.spec, dist_dir=dist_override, work_dir=work_override)
    except subprocess.CalledProcessError as e:
        print('PyInstaller failed with', e.returncode)
        return e.returncode
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))