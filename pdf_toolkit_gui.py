#!/usr/bin/env python3
"""
PDF Toolkit GUI: Shrink and Split PDFs using Tkinter.
- Shrink tab wraps compress_scanned_pdf (PyMuPDF + Pillow)
- Split tab wraps split_pdf.split_pdf (PyMuPDF)
"""
import os
import threading
import queue
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# Add optional version import generated by build.py
try:
    from version import __version__
except ImportError:
    __version__ = 'dev'

from shrink_scanned_pdf import compress_scanned_pdf, human
import split_pdf as splitter
import merge_pdf as merger


class PdfToolkitApp(tk.Tk):
    def __init__(self):
        super().__init__()
        # include build version and GitHub handle in title
        self.title(f"PDF Toolkit — v{__version__} by ktsouvalis")
        self.geometry("720x540")
        self.minsize(640, 480)
        # Fixed size window; keep minimize/close
        self.resizable(False, False)
        self.after(0, lambda: self._enforce_no_maximize_windows())

        self.q = queue.Queue()
        self.running = False

        nb = ttk.Notebook(self)
        nb.pack(fill='both', expand=True)

        self.shrink_tab = ttk.Frame(nb)
        self.split_tab = ttk.Frame(nb)
        self.merge_tab = ttk.Frame(nb)
        nb.add(self.shrink_tab, text="Shrink")
        nb.add(self.split_tab, text="Split")
        nb.add(self.merge_tab, text="Merge")

        self._build_shrink_tab(self.shrink_tab)
        self._build_split_tab(self.split_tab)
        self._build_merge_tab(self.merge_tab)

        self.after(100, lambda: self._poll_queue())

    def _enforce_no_maximize_windows(self):
        try:
            if os.name != 'nt':
                return
            import ctypes
            GWL_STYLE = -16
            WS_MAXIMIZEBOX = 0x00010000
            WS_THICKFRAME = 0x00040000
            SWP_NOSIZE = 0x0001
            SWP_NOMOVE = 0x0002
            SWP_NOZORDER = 0x0004
            SWP_FRAMECHANGED = 0x0020
            hwnd = self.winfo_id()
            user32 = ctypes.windll.user32
            style = user32.GetWindowLongW(hwnd, GWL_STYLE)
            new_style = style & ~WS_MAXIMIZEBOX & ~WS_THICKFRAME
            if new_style != style:
                user32.SetWindowLongW(hwnd, GWL_STYLE, new_style)
                user32.SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED)
        except Exception:
            pass

    # ===== Shrink tab =====
    def _build_shrink_tab(self, root: ttk.Frame):
        self.shrink_running = False
        self.input_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.preset = tk.StringVar(value="medium")
        self.dpi = tk.IntVar(value=150)
        self.quality = tk.IntVar(value=60)
        self.grayscale = tk.BooleanVar(value=False)

        pad = {"padx": 8, "pady": 6}
        frm = ttk.Frame(root)
        frm.pack(fill='both', expand=True)

        ttk.Label(frm, text="Input PDF:").grid(row=0, column=0, sticky='w', **pad)
        input_row = ttk.Frame(frm); input_row.grid(row=0, column=1, sticky='ew', **pad)
        frm.columnconfigure(1, weight=1)
        self.ent_input = ttk.Entry(input_row, textvariable=self.input_path)
        self.ent_input.pack(side='left', fill='x', expand=True)
        ttk.Button(input_row, text="Browse…", command=self._shr_choose_input).pack(side='left', padx=6)

        ttk.Label(frm, text="Output PDF:").grid(row=1, column=0, sticky='w', **pad)
        output_row = ttk.Frame(frm); output_row.grid(row=1, column=1, sticky='ew', **pad)
        self.ent_output = ttk.Entry(output_row, textvariable=self.output_path)
        self.ent_output.pack(side='left', fill='x', expand=True)
        ttk.Button(output_row, text="Browse…", command=self._shr_choose_output).pack(side='left', padx=6)

        ttk.Label(frm, text="Preset:").grid(row=2, column=0, sticky='w', **pad)
        preset_row = ttk.Frame(frm); preset_row.grid(row=2, column=1, sticky='w', **pad)
        buttons = [
            ("light", "Light (200 DPI, Q75)"),
            ("medium", "Medium (150, Q60)"),
            ("aggressive", "Aggressive (120, Q50)"),
            ("custom", "Custom"),
        ]
        for idx, (val, text) in enumerate(buttons):
            rb = ttk.Radiobutton(preset_row, text=text, value=val, variable=self.preset, command=self._apply_preset)
            rb.grid(row=idx // 2, column=idx % 2, sticky='w', padx=(0, 16), pady=(0, 4))

        adv = ttk.LabelFrame(frm, text="Settings")
        adv.grid(row=3, column=0, columnspan=2, sticky='ew', **pad)
        adv.columnconfigure(1, weight=1)
        ttk.Label(adv, text="DPI:").grid(row=0, column=0, sticky='w', **pad)
        self.spn_dpi = ttk.Spinbox(adv, from_=60, to=600, increment=10, textvariable=self.dpi, width=8)
        self.spn_dpi.grid(row=0, column=1, sticky='w', **pad)
        ttk.Label(adv, text="JPEG Quality:").grid(row=0, column=2, sticky='w', **pad)
        self.spn_quality = ttk.Spinbox(adv, from_=1, to=100, increment=1, textvariable=self.quality, width=8)
        self.spn_quality.grid(row=0, column=3, sticky='w', **pad)
        self.chk_gray = ttk.Checkbutton(adv, text="Grayscale", variable=self.grayscale)
        self.chk_gray.grid(row=0, column=4, sticky='w', **pad)

        btn_row = ttk.Frame(frm); btn_row.grid(row=4, column=0, columnspan=2, sticky='ew', **pad)
        btn_row.columnconfigure(0, weight=1)
        self.btn_run = ttk.Button(btn_row, text="Shrink PDF", command=self._on_shrink)
        self.btn_run.grid(row=0, column=0, sticky='e')

        prg_row = ttk.Frame(frm); prg_row.grid(row=5, column=0, columnspan=2, sticky='ew', **pad)
        prg_row.columnconfigure(0, weight=1)
        self.prg_shrink = ttk.Progressbar(prg_row, mode='determinate')
        self.prg_shrink.grid(row=0, column=0, sticky='ew', padx=2)
        self.lbl_status_shrink = ttk.Label(prg_row, text="Idle")
        self.lbl_status_shrink.grid(row=1, column=0, sticky='w', padx=2, pady=(2, 0))

        self._apply_preset()

    def _shr_choose_input(self):
        path = filedialog.askopenfilename(filetypes=[('PDF files', '*.pdf'), ('All files', '*.*')])
        if not path:
            return
        self.input_path.set(path)
        base, _ = os.path.splitext(path)
        self.output_path.set(base + '.shrink.pdf')

    def _shr_choose_output(self):
        initial = self.output_path.get() or 'output.shrink.pdf'
        path = filedialog.asksaveasfilename(defaultextension='.pdf', initialfile=os.path.basename(initial), filetypes=[('PDF files', '*.pdf')])
        if path:
            self.output_path.set(path)

    def _apply_preset(self):
        p = self.preset.get()
        is_custom = p == 'custom'
        for w in (self.spn_dpi, self.spn_quality):
            w.state(['!disabled'] if is_custom else ['disabled'])
        if p == 'light':
            self.dpi.set(200); self.quality.set(75)
        elif p == 'medium':
            self.dpi.set(150); self.quality.set(60)
        elif p == 'aggressive':
            self.dpi.set(120); self.quality.set(50)

    def _on_shrink(self):
        if self.running:
            return
        in_path = self.input_path.get().strip()
        out_path = self.output_path.get().strip()
        if not in_path:
            messagebox.showwarning('Missing input', 'Please choose an input PDF.')
            return
        if not os.path.isfile(in_path):
            messagebox.showerror('File not found', f'Input not found:\n{in_path}')
            return
        if not out_path:
            base, _ = os.path.splitext(in_path)
            out_path = base + '.shrink.pdf'
            self.output_path.set(out_path)

        dpi = int(self.dpi.get())
        quality = int(self.quality.get())
        grayscale = bool(self.grayscale.get())

        self.running = True
        self._set_shrink_controls(False)
        self.prg_shrink.configure(value=0, maximum=100)
        self.lbl_status_shrink.configure(text='Starting…')

        def progress(i, total):
            try:
                self.q.put(('shrink-progress', i, total))
            except Exception:
                pass

        def worker():
            try:
                compress_scanned_pdf(
                    input_path=in_path,
                    output_path=out_path,
                    dpi=dpi,
                    quality=quality,
                    grayscale=grayscale,
                    progress_callback=progress,
                )
                before = os.path.getsize(in_path)
                after = os.path.getsize(out_path) if os.path.exists(out_path) else 0
                saved = before - after
                pct = (saved / before * 100.0) if before > 0 else 0.0
                self.q.put(('shrink-done', before, after, saved, pct))
            except Exception as e:
                self.q.put(('shrink-error', str(e)))

        threading.Thread(target=worker, daemon=True).start()

    def _set_shrink_controls(self, enabled: bool):
        state = tk.NORMAL if enabled else tk.DISABLED
        for w in [self.ent_input, self.ent_output, self.spn_dpi, self.spn_quality, self.chk_gray, self.btn_run]:
            try:
                w.configure(state=state)
            except Exception:
                pass
        if enabled:
            self._apply_preset()

    # ===== Split tab =====
    def _build_split_tab(self, root: ttk.Frame):
        self.split_input = tk.StringVar()
        self.split_outdir = tk.StringVar()
        self.split_prefix = tk.StringVar(value='')
        self.split_mode = tk.StringVar(value='every')  # 'every' or 'points'
        self.split_every = tk.IntVar(value=3)
        self.split_points_str = tk.StringVar(value='5,10')

        pad = {"padx": 8, "pady": 6}
        frm = ttk.Frame(root)
        frm.pack(fill='both', expand=True)

        ttk.Label(frm, text="Input PDF:").grid(row=0, column=0, sticky='w', **pad)
        input_row = ttk.Frame(frm); input_row.grid(row=0, column=1, sticky='ew', **pad)
        frm.columnconfigure(1, weight=1)
        self.ent_split_input = ttk.Entry(input_row, textvariable=self.split_input)
        self.ent_split_input.pack(side='left', fill='x', expand=True)
        ttk.Button(input_row, text="Browse…", command=self._split_choose_input).pack(side='left', padx=6)

        ttk.Label(frm, text="Output folder:").grid(row=1, column=0, sticky='w', **pad)
        out_row = ttk.Frame(frm); out_row.grid(row=1, column=1, sticky='ew', **pad)
        self.ent_split_outdir = ttk.Entry(out_row, textvariable=self.split_outdir)
        self.ent_split_outdir.pack(side='left', fill='x', expand=True)
        ttk.Button(out_row, text="Browse…", command=self._split_choose_outdir).pack(side='left', padx=6)

        mode = ttk.LabelFrame(frm, text="Mode")
        mode.grid(row=2, column=0, columnspan=2, sticky='ew', **pad)
        # Every N
        rb_every = ttk.Radiobutton(mode, text="Split every N pages", value='every', variable=self.split_mode, command=self._update_split_mode)
        rb_every.grid(row=0, column=0, sticky='w', padx=(8, 8), pady=(4, 4))
        ttk.Label(mode, text="N:").grid(row=0, column=1, sticky='w')
        self.spn_every = ttk.Spinbox(mode, from_=1, to=999, increment=1, textvariable=self.split_every, width=6)
        self.spn_every.grid(row=0, column=2, sticky='w', padx=(4, 8))
        # Points
        rb_points = ttk.Radiobutton(mode, text="Split at pages (comma-separated, 1-based)", value='points', variable=self.split_mode, command=self._update_split_mode)
        rb_points.grid(row=1, column=0, columnspan=2, sticky='w', padx=(8, 8), pady=(4, 4))
        self.ent_points = ttk.Entry(mode, textvariable=self.split_points_str, width=40)
        self.ent_points.grid(row=1, column=2, sticky='w', padx=(4, 8))

        # Prefix
        pre_row = ttk.Frame(frm); pre_row.grid(row=3, column=0, columnspan=2, sticky='ew', **pad)
        ttk.Label(pre_row, text="Output prefix (optional):").pack(side='left')
        self.ent_prefix = ttk.Entry(pre_row, textvariable=self.split_prefix, width=24)
        self.ent_prefix.pack(side='left', padx=(6, 0))

        # Actions
        btn_row = ttk.Frame(frm)
        btn_row.grid(row=4, column=0, columnspan=2, sticky='ew', **pad)
        btn_row.columnconfigure(0, weight=1)
        self.btn_split_run = ttk.Button(btn_row, text="Split PDF", command=self._on_split)
        self.btn_split_run.grid(row=0, column=0, sticky='e')

        # Progress
        prg_row = ttk.Frame(frm)
        prg_row.grid(row=5, column=0, columnspan=2, sticky='ew', **pad)
        prg_row.columnconfigure(0, weight=1)
        self.prg_split = ttk.Progressbar(prg_row, mode='determinate')
        self.prg_split.grid(row=0, column=0, sticky='ew', padx=2)
        self.lbl_status_split = ttk.Label(prg_row, text="Idle")
        self.lbl_status_split.grid(row=1, column=0, sticky='w', padx=2, pady=(2, 0))

        self._update_split_mode()

    def _split_choose_input(self):
        path = filedialog.askopenfilename(filetypes=[('PDF files', '*.pdf'), ('All files', '*.*')])
        if not path:
            return
        self.split_input.set(path)
        # default outdir next to input
        self.split_outdir.set(os.path.dirname(os.path.abspath(path)))

    def _split_choose_outdir(self):
        path = filedialog.askdirectory()
        if path:
            self.split_outdir.set(path)

    def _update_split_mode(self):
        is_every = self.split_mode.get() == 'every'
        try:
            self.spn_every.state(['!disabled'] if is_every else ['disabled'])
        except Exception:
            pass
        try:
            self.ent_points.configure(state=(tk.DISABLED if is_every else tk.NORMAL))
        except Exception:
            pass

    def _on_split(self):
        if self.running:
            return
        in_path = self.split_input.get().strip()
        outdir = self.split_outdir.get().strip()
        prefix = self.split_prefix.get().strip() or None
        if not in_path:
            messagebox.showwarning('Missing input', 'Please choose an input PDF.')
            return
        if not os.path.isfile(in_path):
            messagebox.showerror('File not found', f'Input not found:\n{in_path}')
            return
        if not outdir:
            outdir = os.path.dirname(os.path.abspath(in_path))
            self.split_outdir.set(outdir)

        mode = self.split_mode.get()
        every = None
        points = None
        if mode == 'every':
            try:
                every = int(self.split_every.get())
                if every <= 0:
                    raise ValueError
            except Exception:
                messagebox.showerror('Invalid value', 'N must be a positive integer.')
                return
        else:
            try:
                points = splitter.parse_split_points(self.split_points_str.get())
                if not points:
                    raise ValueError
            except Exception:
                messagebox.showerror('Invalid value', 'Please enter valid comma-separated page numbers.')
                return

        self.running = True
        self._set_split_controls(False)
        self.prg_split.configure(value=0, maximum=100)
        self.lbl_status_split.configure(text='Starting…')

        def progress(i, total):
            try:
                self.q.put(('split-progress', i, total))
            except Exception:
                pass

        def worker():
            try:
                created = splitter.split_pdf(
                    input_path=in_path,
                    outdir=outdir,
                    every=every,
                    split_at=points,
                    prefix=prefix,
                    progress_callback=progress,
                )
                self.q.put(('split-done', created))
            except Exception as e:
                self.q.put(('split-error', str(e)))

        threading.Thread(target=worker, daemon=True).start()

    def _set_split_controls(self, enabled: bool):
        state = tk.NORMAL if enabled else tk.DISABLED
        widgets = [self.ent_split_input, self.ent_split_outdir, self.ent_prefix, self.spn_every, self.ent_points, self.btn_split_run]
        for w in widgets:
            try:
                w.configure(state=state)
            except Exception:
                pass
        if enabled:
            self._update_split_mode()

    # ===== Merge tab =====
    def _build_merge_tab(self, root: ttk.Frame):
        self.merge_output = tk.StringVar()
        self.merge_files: list[str] = []

        pad = {"padx": 8, "pady": 6}
        frm = ttk.Frame(root)
        frm.pack(fill='both', expand=True)

        # File list and actions
        list_row = ttk.Frame(frm)
        list_row.grid(row=0, column=0, columnspan=2, sticky='nsew', **pad)
        frm.rowconfigure(0, weight=1)
        frm.columnconfigure(0, weight=1)
        self.lb_files = tk.Listbox(list_row, selectmode=tk.EXTENDED, height=12)
        self.lb_files.pack(side='left', fill='both', expand=True)
        scrollbar = ttk.Scrollbar(list_row, orient='vertical', command=self.lb_files.yview)
        scrollbar.pack(side='left', fill='y')
        self.lb_files.configure(yscrollcommand=scrollbar.set)

        buttons_col = ttk.Frame(list_row)
        buttons_col.pack(side='left', fill='y', padx=(8, 0))
        ttk.Button(buttons_col, text="Add PDFs…", command=self._merge_add_files).pack(fill='x', pady=2)
        ttk.Button(buttons_col, text="Remove", command=self._merge_remove_selected).pack(fill='x', pady=2)
        ttk.Button(buttons_col, text="Move Up", command=self._merge_move_up).pack(fill='x', pady=2)
        ttk.Button(buttons_col, text="Move Down", command=self._merge_move_down).pack(fill='x', pady=2)
        ttk.Button(buttons_col, text="Clear", command=self._merge_clear).pack(fill='x', pady=2)

        # Output picker
        out_row = ttk.Frame(frm)
        out_row.grid(row=1, column=0, columnspan=2, sticky='ew', **pad)
        ttk.Label(out_row, text="Output PDF:").pack(side='left')
        self.ent_merge_output = ttk.Entry(out_row, textvariable=self.merge_output)
        self.ent_merge_output.pack(side='left', fill='x', expand=True, padx=(8, 8))
        ttk.Button(out_row, text="Browse…", command=self._merge_choose_output).pack(side='left')

        # Actions / Progress
        act_row = ttk.Frame(frm)
        act_row.grid(row=2, column=0, columnspan=2, sticky='ew', **pad)
        act_row.columnconfigure(0, weight=1)
        self.btn_merge_run = ttk.Button(act_row, text="Merge PDFs", command=self._on_merge)
        self.btn_merge_run.grid(row=0, column=0, sticky='e')

        prg_row = ttk.Frame(frm)
        prg_row.grid(row=3, column=0, columnspan=2, sticky='ew', **pad)
        prg_row.columnconfigure(0, weight=1)
        self.prg_merge = ttk.Progressbar(prg_row, mode='determinate')
        self.prg_merge.grid(row=0, column=0, sticky='ew', padx=2)
        self.lbl_status_merge = ttk.Label(prg_row, text="Idle")
        self.lbl_status_merge.grid(row=1, column=0, sticky='w', padx=2, pady=(2, 0))

    def _merge_add_files(self):
        paths = filedialog.askopenfilenames(filetypes=[('PDF files', '*.pdf')])
        if not paths:
            return
        for p in paths:
            if p not in self.merge_files:
                self.merge_files.append(p)
                self.lb_files.insert(tk.END, p)
        # Suggest output next to first file
        if not self.merge_output.get() and self.merge_files:
            base_dir = os.path.dirname(self.merge_files[0])
            self.merge_output.set(os.path.join(base_dir, 'merged.pdf'))

    def _merge_remove_selected(self):
        sel = list(self.lb_files.curselection())
        if not sel:
            return
        # remove from end to start to keep indices valid
        for idx in reversed(sel):
            self.lb_files.delete(idx)
            del self.merge_files[idx]

    def _merge_move_up(self):
        sel = list(self.lb_files.curselection())
        if not sel:
            return
        for idx in sel:
            if idx == 0:
                continue
            self.merge_files[idx-1], self.merge_files[idx] = self.merge_files[idx], self.merge_files[idx-1]
        # rebuild listbox and reselect moved items
        self._merge_refresh_listbox(new_selection=[i-1 for i in sel if i > 0])

    def _merge_move_down(self):
        sel = list(self.lb_files.curselection())
        if not sel:
            return
        for idx in reversed(sel):
            if idx >= len(self.merge_files) - 1:
                continue
            self.merge_files[idx+1], self.merge_files[idx] = self.merge_files[idx], self.merge_files[idx+1]
        self._merge_refresh_listbox(new_selection=[i+1 for i in sel if i < len(self.merge_files)-1])

    def _merge_clear(self):
        self.merge_files.clear()
        self.lb_files.delete(0, tk.END)

    def _merge_refresh_listbox(self, new_selection=None):
        self.lb_files.delete(0, tk.END)
        for p in self.merge_files:
            self.lb_files.insert(tk.END, p)
        if new_selection:
            for i in new_selection:
                try:
                    self.lb_files.selection_set(i)
                except Exception:
                    pass

    def _merge_choose_output(self):
        initial = self.merge_output.get() or 'merged.pdf'
        path = filedialog.asksaveasfilename(defaultextension='.pdf', initialfile=os.path.basename(initial), filetypes=[('PDF files', '*.pdf')])
        if path:
            self.merge_output.set(path)

    def _on_merge(self):
        if self.running:
            return
        files = list(self.merge_files)
        out_path = self.merge_output.get().strip()
        if len(files) < 2:
            messagebox.showwarning('Need more files', 'Please add at least two PDF files to merge.')
            return
        for p in files:
            if not os.path.isfile(p):
                messagebox.showerror('File not found', f'Input not found:\n{p}')
                return
        if not out_path:
            base_dir = os.path.dirname(files[0])
            out_path = os.path.join(base_dir, 'merged.pdf')
            self.merge_output.set(out_path)

        self.running = True
        self._set_merge_controls(False)
        self.prg_merge.configure(value=0, maximum=max(1, len(files)))
        self.lbl_status_merge.configure(text='Starting…')

        def progress(i, total):
            try:
                self.q.put(('merge-progress', i, total))
            except Exception:
                pass

        def worker():
            try:
                result = merger.merge_pdfs(files, out_path, progress_callback=progress)
                self.q.put(('merge-done', result))
            except Exception as e:
                self.q.put(('merge-error', str(e)))

        threading.Thread(target=worker, daemon=True).start()

    def _set_merge_controls(self, enabled: bool):
        state = tk.NORMAL if enabled else tk.DISABLED
        widgets = [self.lb_files, self.ent_merge_output, self.btn_merge_run]
        for w in widgets:
            try:
                w.configure(state=state)
            except Exception:
                pass

    # ===== Event loop =====
    def _poll_queue(self):
        try:
            while True:
                item = self.q.get_nowait()
                kind = item[0]
                if kind == 'shrink-progress':
                    _, i, total = item
                    self.prg_shrink.configure(maximum=total, value=i)
                    self.lbl_status_shrink.configure(text=f"Processing page {i}/{total}…")
                elif kind == 'shrink-done':
                    _, before, after, saved, pct = item
                    self.prg_shrink.configure(value=self.prg_shrink['maximum'] or 100)
                    self.lbl_status_shrink.configure(text=f"Done. Saved {human(saved)} ({pct:.1f}% reduction)")
                    self._set_shrink_controls(True)
                    self.running = False
                    messagebox.showinfo('Shrink complete', f"Input: {human(before)}\nOutput: {human(after)}\nSaved: {human(saved)} ({pct:.1f}% reduction)")
                elif kind == 'shrink-error':
                    _, msg = item
                    self.lbl_status_shrink.configure(text='Error')
                    self._set_shrink_controls(True)
                    self.running = False
                    messagebox.showerror('Error', msg)
                elif kind == 'split-progress':
                    _, i, total = item
                    self.prg_split.configure(maximum=total, value=i)
                    self.lbl_status_split.configure(text=f"Writing part {i}/{total}…")
                elif kind == 'split-done':
                    _, created = item
                    self.prg_split.configure(value=self.prg_split['maximum'] or 100)
                    self.lbl_status_split.configure(text=f"Done. Created {len(created)} file(s)")
                    self._set_split_controls(True)
                    self.running = False
                    if created:
                        msg = "\n".join(created[:10])
                        more = "" if len(created) <= 10 else f"\n...and {len(created)-10} more"
                        messagebox.showinfo('Split complete', f"Created {len(created)} file(s):\n{msg}{more}")
                    else:
                        messagebox.showinfo('Split complete', 'No output created.')
                elif kind == 'split-error':
                    _, msg = item
                    self.lbl_status_split.configure(text='Error')
                    self._set_split_controls(True)
                    self.running = False
                    messagebox.showerror('Error', msg)
                elif kind == 'merge-progress':
                    _, i, total = item
                    self.prg_merge.configure(maximum=total, value=i)
                    self.lbl_status_merge.configure(text=f"Merging {i}/{total}…")
                elif kind == 'merge-done':
                    _, result = item
                    self.prg_merge.configure(value=self.prg_merge['maximum'] or 100)
                    self.lbl_status_merge.configure(text=f"Done. Created: {os.path.basename(result)}")
                    self._set_merge_controls(True)
                    self.running = False
                    messagebox.showinfo('Merge complete', f"Created: {result}")
                elif kind == 'merge-error':
                    _, msg = item
                    self.lbl_status_merge.configure(text='Error')
                    self._set_merge_controls(True)
                    self.running = False
                    messagebox.showerror('Error', msg)
                self.q.task_done()
        except queue.Empty:
            pass
        finally:
            self.after(100, lambda: self._poll_queue())


if __name__ == '__main__':
    PdfToolkitApp().mainloop()